---
配置Tomcat 管理界面layout: post
title:  "tomcat"
categories: middleware
tags: tomcat
author: joshua
description: tomcat
---
### tomcat

tomcat服务器：Apache公司研发，支持JavaEE的部分规范。开源免费
weblogic服务器：Oracle公司提供，它支持JavaEE的所有规范，商用收费
WebSphere服务器：IBM公司提供，它支持JavaEE的所有规范，商用收费

Tomcat 是美国阿帕奇（Apache）软件基金会的一款**轻量级 Web 应用服务器**。该程序实现了对**Servlet** 和**JavaServerPage**（JSP）的支持

[CATALINA_HOME  CATALINA_BASE](https://tomcat.apache.org/tomcat-9.0-doc/introduction.html)

**CATALINA_HOME**: Represents the root of your Tomcat installation
**CATALINA_BASE**: Represents the root of a runtime configuration of a specific Tomcat instance.
If you want to have **multiple** Tomcat instances on one machine, use the CATALINA_BASE property

By default, CATALINA_HOME and CATALINA_BASE point to the same directory. 

Set CATALINA_BASE manually when you require running **multiple** Tomcat instances on one machine. Doing so provides the following benefits:

```text
 Easier management of upgrading to a newer version of Tomcat. Because all instances with single CATALINA_HOME location share one set of .jar files and binary files, you can easily upgrade the files to newer version and have the change propagated to all Tomcat instances using the same CATALIA_HOME directory.
​ Avoiding duplication of the same static .jar files.
​ The possibility to share certain settings, for example the setenv shell or bat script file (depending on your operating system).
```

Contents of CATALINA_BASE
    **bin** directory with the setenv.sh, setenv.bat, and tomcat-juli.jar files.
        CATALINA_BASE is checked first; ==fallback== is provided to CATALINA_HOME.
    **lib** directory with further resources to be added on classpath.
        CATALINA_BASE is checked first; CATALINA_HOME is loaded ==second==.
    **logs** directory for instance-specific log files.
    **webapps** directory for automatically loaded web applications.
        CATALINA_BASE ==only==.
    **work** directory that contains temporary working directories for the deployed web applications.
    **temp** directory used by the JVM for temporary files.

At **minimum**, CATALINA_BASE must contain:

```text
conf/server.xml
conf/web.xml
```



#### [java要求](https://tomcat.apache.org/tomcat-9.0-doc/RUNNING.txt)

Tomcat 8.5 要求 JDK 版本为 1.7 以上
Tomcat 9.0 requires a Java Standard Edition Runtime Environment (JRE) version 8 or later.

#### [Tomcat Versions](https://tomcat.apache.org/whichversion.html)

| **Servlet Spec** | **JSP Spec** | **EL Spec** | **WebSocket Spec** | **Authentication (JASIC) Spec** | **Apache Tomcat Version** | **Latest Released Version** | **Supported Java Versions**             |
| :--------------- | :----------- | :---------- | :----------------- | :------------------------------ | :------------------------ | :-------------------------- | :-------------------------------------- |
| 5.0              | 3.0          | 4.0         | 2.0                | 2.0                             | 10.0.x                    | 10.0.0-M5 (alpha)           | 8 and later                             |
| 4.0              | 2.3          | 3.0         | 1.1                | 1.1                             | 9.0.x                     | 9.0.35                      | 8 and later                             |
| 3.1              | 2.3          | 3.0         | 1.1                | 1.1                             | 8.5.x                     | 8.5.55                      | 7 and later                             |
| 3.1              | 2.3          | 3.0         | 1.1                | N/A                             | 8.0.x (superseded)        | 8.0.53 (superseded)         | 7 and later                             |
| 3.0              | 2.2          | 2.2         | 1.1                | N/A                             | 7.0.x                     | 7.0.104                     | 6 and later (7 and later for WebSocket) |
| 2.5              | 2.1          | 2.1         | N/A                | N/A                             | 6.0.x (archived)          | 6.0.53 (archived)           | 5 and later                             |
| 2.4              | 2.0          | N/A         | N/A                | N/A                             | 5.5.x (archived)          | 5.5.36 (archived)           | 1.4 and later                           |
| 2.3              | 1.2          | N/A         | N/A                | N/A                             | 4.1.x (archived)          | 4.1.40 (archived)           | 1.3 and later                           |
| 2.2              | 1.1          | N/A         | N/A                | N/A                             | 3.3.x (archived)          | 3.3.2 (archived)            | 1.1 and later                           |

**Alpha** releases may contain **large amounts** of untested/missing functionality required by the specification and/or significant bugs and are not expected to run stably for any length of time.

**Beta** releases may contain **some** untested functionality and/or a number of relatively minor bugs. Beta releases are not expected to run stably.

**Stable** releases may contain a small number of relatively minor bugs. Stable releases are intended for production use and are expected to run stably for extended periods of time.

#### [java下载](http://www.oracle.com/technetwork/java/javase/downloads/index.html)

You may also use a full Java Development Kit (JDK) rather than just a JRE.



#### [tomcat下载](https://tomcat.apache.org/)

https://tomcat.apache.org/download-80.cgi
https://tomcat.apache.org/download-90.cgi
http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.13/bin/apache-tomcat-9.0.13.tar.gz

As an alternative to downloading a **binary** distribution, you can create your own from the Tomcat ==source== code, as described in "==BUILDING.txt=="

```text
(3.1) Set CATALINA_HOME (required) and CATALINA_BASE (optional)
(3.2) Set JRE_HOME or JAVA_HOME (required)
(3.3) Other variables (optional)    CATALINA_OPTS JAVA_OPTS CATALINA_PID
(3.4) Using the "setenv" script (optional, recommended)
    By default the setenv script file is absent. If the script file is present
    On Windows, %CATALINA_BASE%\bin\setenv.bat:
        set "JRE_HOME=%ProgramFiles%\Java\jre8"
        exit /b 0
    $CATALINA_BASE/bin/setenv.sh:
        JRE_HOME=/usr/java/latest
        CATALINA_PID="$CATALINA_BASE/tomcat.pid"
```

```sh
%CATALINA_HOME%\bin\startup.bat
%CATALINA_HOME%\bin\catalina.bat start
$CATALINA_HOME/bin/startup.sh
$CATALINA_HOME/bin/catalina.sh start
http://localhost:8080/

%CATALINA_HOME%\bin\shutdown.bat
%CATALINA_HOME%\bin\catalina.bat stop
$CATALINA_HOME/bin/shutdown.sh
$CATALINA_HOME/bin/catalina.sh stop
```

**In CATALINA_BASE:**

* bin  - Only the following files:
        * setenv.sh (*nix) or setenv.bat (Windows),
        * tomcat-juli.jar
             The setenv scripts were described above. The tomcat-juli library is documented in the Logging chapter in the User Guide.
* conf - Server configuration files (including server.xml)
* lib  - Libraries and classes, as explained below
* logs - Log and output files
* webapps - Automatically loaded web applications
* work - Temporary working directories for web applications
* temp - Directory used by the JVM for temporary files (java.io.tmpdir)

**In CATALINA_HOME:**

* bin  - Startup and shutdown scripts
         The following files will be used only if they are absent in CATALINA_BASE/bin:
         setenv.sh (*nix), setenv.bat (Windows), tomcat-juli.jar
* lib  - Libraries and classes, as explained below
* endorsed - Libraries that override standard "Endorsed Standards"
             libraries provided by JRE. See Classloading documentation in the User Guide for details.
             This is only supported for Java <= 8. By default this "endorsed" directory is absent.



```text
It might be useful to note that the values of CATALINA_HOME and CATALINA_BASE can be referenced in the XML configuration files processed by Tomcat as ${catalina.home} and ${catalina.base} respectively.
```



#### manager

the standard manager web application can be kept in CATALINA_HOME/webapps/manager and loaded into CATALINA_BASE by using the following trick:

```sh
cp CATALINA_HOME/webapps/manager/META-INF/context.xml file CATALINA_BASE/conf/Catalina/localhost/manager.xml
```

```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <Context docBase="${catalina.home}/webapps/manager"
            antiResourceLocking="false" privileged="true" >
            <Valve className="org.apache.catalina.valves.RemoteAddrValve"
                allow="127\.0\.0\.1" />
        </Context>
```

```sh
cp webapps/host-manager/META-INF/context.xml conf/Catalina/localhost/host-manager.xml
```

```xml
allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1|192\.168\.118\.1" />
```



### [Tomcat工作原理](https://blog.csdn.net/chentianming11/article/details/78724232)

##### Tomcat总体结构

Tomcat的2个最核心的组件就是Connector连接器和Container容器。一个Container可以对应选择多个Connector。多个 Connector 和一个 Container 就形成了一个 Service，有个Service就可以对外提供服务了。Tomcat就是一个Server服务器，它里面可以包含多个Service服务。

##### Server服务器

每启动一个Tomcat，实际上就是启动了一个Server服务器实例，它监听一个端口以接收shutdown命令。在同一台物理机器上启动多个Server，必须配置它们使用不同的端口。不过基于安全考虑，一台机器上我们一般只会启动一个Server服务器。一个Server中可以包含多个Service服务。Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到这个 Service 集合、同时要维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。

##### Service服务

多个 Connector 和一个 Container 就形成了一个 Service。其中，Connector组件主要负责对外交流，Container组件则是处理来自Connector接收的请求。说白了，Service中封装了Connector和Container，然后向外提供服务。一个Service可以设置多个Connector连接器，但是只能有一个Container容器。Service接口的方法列表如下：

从Servicce接口中定义的方法也可以看出，Service关联了Connector和Container，同时会初始化它下面的其它组件。Service接口的标准实现类是StandardService，它不仅实现了Service接口，同时还实现了LifeCycle接口。LifeCycle用来控制所有组件的生命周期。

##### Connector连接器

Connector的主要任务是负责接收浏览器发送过来的Tcp请求，然后创建一个Request请求对象和Response响应对象（依据不同的协议会创建对用的Request和response）。Request中封装了浏览器的请求信息，Response中封装了反馈给浏览器的响应信息。之后，会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理这个请求的线程任务，处理这个请求的线程就是 Container 组件要做的事了。

##### Container组件

Container 是容器的父接口，所有子容器都必须实现这个接口。它有四个子容器组件构成，分别是：Engine、Host、Context、Wrapper，这四个组件不是平行的，而是父子关系，Engine 包含 Host,Host 包含 Context，Context 包含 Wrapper。通常一个 Servlet class 对应一个 Wrapper，如果有多个 Servlet 就可以定义多个 Wrapper。

##### Engine组件

Engine是Servlet处理器的一个实例，即servlet引擎。

##### Host组件

Host 是 Engine 的子容器，一个 Host 在 Engine 中代表一个虚拟主机，这个虚拟主机的作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context，它除了关联子容器外，还有就是保存一个主机应该有的信息。

##### Context组件

Context 就是 Servlet 的容器，它具备了 Servlet 运行的基本环境，理论上只要有 Context 就能运行 Servlet 了。简单的 Tomcat 可以没有 Engine 和 Host。
Context 最重要的功能就是用于标识tomcat实例中的一个Web应用程序（Servlet程序），Servlet 实例在 Context 中是以 Wrapper 出现的。

##### Wrapper组件

Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。

##### Tomcat的启动过程

创建一个Tomcat实例对象并调用 start 方法就可以很容易启动 Tomcat，我们还可以通过这个对象来增加和修改 Tomcat 的配置参数，如可以动态增加 Context、Servlet 等。下面我们就利用这个 Tomcat 类来管理新增的一个 Context 容器，我们就选择 Tomcat7 自带的 examples Web 工程，并看看它是如何加到这个 Context 容器中的。

```java
Tomcat tomcat = getTomcatInstance(); //创建一个Tomcat对象
//将应用程序的路径封装成一个File对象
File appDir = new File(getBuildDirectory(), "webapps/examples"); 
//通过tomcat的addWebAPP()方法，新增一个Web应用到Tomcat中
tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); 
//启动Tomcat
tomcat.start(); 
//调用其中的一个HelloWorldExample Servlet
ByteChunk res = getUrl("http://localhost:" + getPort() + 
              "/examples/servlets/servlet/HelloWorldExample"); 
assertTrue(res.toString().indexOf("<h1>Hello World!</h1>") > 0);
```


Tomcat 的 addWebapp 方法的代码如下：

```java
public Context addWebapp(Host host, String url, String path) { 
       silence(url); 
       Context ctx = new StandardContext(); //创建一个Context对象
       ctx.setPath( url ); //设置Context的路径
       ctx.setDocBase(path); 
       if (defaultRealm == null) { 
           initSimpleAuth(); 
       } 
       ctx.setRealm(defaultRealm); 
       ctx.addLifecycleListener(new DefaultWebXmlListener()); 
       ContextConfig ctxCfg = new ContextConfig(); 
       ctx.addLifecycleListener(ctxCfg); //创建ContextConfig对象
       ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); 
       if (host == null) { 
           getHost().addChild(ctx); 
       } else { 
           host.addChild(ctx); //将Context对象添加到一个host中
       } 
       return ctx; 
}
```

一个web应用对应一个Context容器，也就是Servlet运行时的Servlet容器。添加一个web应用时会创建一个StandardContext容器，并且会给这个容器设置必要的参数。ContextConfig对象会负责整个web应用配置的解析。最后将这个Context容器添加到父容器Host中。

##### Tomcat的请求过程

Tomcat服务器的Connector对象负责与浏览器建立TCP连接。当一个浏览器向服务器发送请求时，该请求就会被HttpConnector接收。HttpConnector创建轻量级对象Request和Response。

1. HttpConnector将Request和Response传递给Container容器进行处理。首先就是根据request快速检索出对应的Servlet对象；这里用到了org.apache.tomcat.util.http.mapper类，这个类保存了 Tomcat 的 Container 容器中的所有子容器的信息，因此Mapper可以立马检索出这个请求对应的servlet。
2. 如果请求的Servlet不存在，Servlet容器就会通过反射创建这个Servlet对象，并调用init()初始化该对象。然后Servlet添加到对应的ServletContext容器中。
3. 在ServletContext中，首先依据Request和Response的内容创建ServletRequest 和 ServletResponse对象。然后将ServletRequest和ServletResponse作为参数，调用Servlet的service()方法。在service()方法中，根据请求的类型会调用对应的doxxx()方法。执行业务逻辑、数据存储等程序。
4. service()方法执行完成之后，Context将HttpServletResponse对象返回给Host。
5. Host把HttpServletResponse对象返回给Engine。
6. Engine把HttpServletResponse对象返回Connector。
7. Connector把Response对象的内容响应给客户Browser。



#### [server.xml配置文件中三个端口的作用](https://blog.csdn.net/u012031380/article/details/77839586)

protocol: HTTP/1.1 协议 ，用于监听浏览器发送的请求. 设置成80 后可以直接使用http://localhost 访问
AJP/1.3   协议 ， 用于监听其他服务器转发过来的请求.
redirectPort: 如果发送的是https 请求. 就将请求转发到8443 端口.

```xml
    <Connector port="8080" protocol="HTTP/1.1"
        connectionTimeout="20000"
        redirectPort="8443" />
<!-- 使用8009 接受其他服务器转发过来的请求 -->
    <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
<!-- tomcat 监听的关闭端口 -->
<Server port="8005" shutdown="SHUTDOWN">

```

AJP（Apache JServ Protocol）是定向包协议。因为性能原因，使用二进制格式来传输可读性文本。WEB服务器通过 TCP连接 和 SERVLET容器连接

由于tomcat的html和图片解析功能相对其他服务器如apche等较弱，所以，一般都是集成起来使用，只有jsp和servlet服务交由tomcat处理，而tomcat和其他服务器的集成，就是通过ajp协议来完成的

<!--注释内容-->
注释可以出现在文档序言中，包括文档类型定义 (DTD)；文档之后；或文本内容中。 
注释不能出现在属性值中。 不能出现在标记中。
分析器在遇到 > 时，就认为注释已结束；然后继续将文档作为正常的 XML 处理。 因此，字符串 > 不能出现在注释中
以下注释可以用于暂时除去标记。
    <!--- <test pattern="SECAM" /><test pattern="NTSC" /> -->



#### [Tomcat连接池数据库密码加密](https://blog.csdn.net/fzzsh/article/details/8863338)





#### [Tomcat 快速入门](https://www.cnblogs.com/jingmoxukong/p/8258837.html)

Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。
由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。
Tomcat 包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置

Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器

##### 一般 web 项目路径结构

```
|-- webapp                         # 站点根目录
    |-- META-INF                   # META-INF 目录
    |   `-- MANIFEST.MF            # 配置清单文件
    |-- WEB-INF                    # WEB-INF 目录
    |   |-- classes                # class文件目录
    |   |   |-- *.class            # 程序需要的 class 文件
    |   |   `-- *.xml              # 程序需要的 xml 文件
    |   |-- lib                    # 库文件夹
    |   |   `-- *.jar              # 程序需要的 jar 包
    |   `-- web.xml                # Web应用程序的部署描述文件
    |-- <userdir>                  # 自定义的目录
    |-- <userfiles>                # 自定义的资源文件
```

`webapp`：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。
`META-INF`：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。
`WEB-INF`：Java web应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。
`/WEB-INF/classes`：存放程序所需要的所有 Java class 文件。
`/WEB-INF/lib`：存放程序所需要的所有 jar 文件。
`/WEB-INF/web.xml`：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。

### Server

> Server 元素表示整个 Catalina servlet 容器。
>因此，它必须是 `conf/server.xml` 配置文件中的根元素。它的属性代表了整个 servlet 容器的特性。

**属性表**

| 属性      | 描述                                                         | 备注                                         |
| --------- | ------------------------------------------------------------ | -------------------------------------------- |
| className | 这个类必须实现org.apache.catalina.Server接口。               | 默认 org.apache.catalina.core.StandardServer |
| address   | 服务器等待关机命令的TCP / IP地址。如果没有指定地址，则使用localhost。 |                                              |
| port      | 服务器等待关机命令的TCP / IP端口号。设置为-1以禁用关闭端口。 |                                              |
| shutdown  | 必须通过TCP / IP连接接收到指定端口号的命令字符串，以关闭Tomcat。 |                                              |

### Service

> Service元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。

**属性表**

| 属性      | 描述                                                         | 备注                                            |
| --------- | ------------------------------------------------------------ | ----------------------------------------------- |
| className | 这个类必须实现`org.apache.catalina.Service`接口。            | 默认 `org.apache.catalina.core.StandardService` |
| name      | 此服务的显示名称，如果您使用标准 Catalina 组件，将包含在日志消息中。与特定服务器关联的每个服务的名称必须是唯一的。 |                                                 |

**实例 - `conf/server.xml` 配置文件示例**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Server port="8005" shutdown="SHUTDOWN">
  <Service name="xxx">
  ...
  </Service>
</Server>
```

### Executor

> Executor表示可以在Tomcat中的组件之间共享的线程池。

**属性表**

| 属性            | 描述                                                         | 备注                                                   |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| className       | 这个类必须实现`org.apache.catalina.Executor`接口。           | 默认 `org.apache.catalina.core.StandardThreadExecutor` |
| name            | 线程池名称。                                                 | 要求唯一, 供Connector元素的executor属性使用            |
| namePrefix      | 线程名称前缀。                                               |                                                        |
| maxThreads      | 最大活跃线程数。                                             | 默认200                                                |
| minSpareThreads | 最小活跃线程数。                                             | 默认25                                                 |
| maxIdleTime     | 当前活跃线程大于minSpareThreads时,空闲线程关闭的等待最大时间。 | 默认60000ms                                            |
| maxQueueSize    | 线程池满情况下的请求排队大小。                               | 默认Integer.MAX_VALUE                                  |

```xml
<Service name="xxx">
  <Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="300" minSpareThreads="25"/>
</Service>
```

### Connector

> Connector代表连接组件。Tomcat 支持三种协议：HTTP/1.1、HTTP/2.0、AJP。

**属性表**

| 属性                  | 说明                                                         | 备注                                                         |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| asyncTimeout          | Servlet3.0规范中的异步请求超时                               | 默认30s                                                      |
| port                  | 请求连接的TCP Port                                           | 设置为0,则会随机选取一个未占用的端口号                       |
| protocol              | 协议. 一般情况下设置为 HTTP/1.1,这种情况下连接模型会在NIO和APR/native中自动根据配置选择 |                                                              |
| URIEncoding           | 对URI的编码方式.                                             | 如果设置系统变量org.apache.catalina.STRICT_SERVLET_COMPLIANCE为true,使用 ISO-8859-1编码;如果未设置此系统变量且未设置此属性, 使用UTF-8编码 |
| useBodyEncodingForURI | 是否采用指定的contentType而不是URIEncoding来编码URI中的请求参数 |                                                              |

以下属性在标准的Connector(NIO, NIO2 和 APR/native)中有效:

| 属性              | 说明                                                         | 备注                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| acceptCount       | 当最大请求连接maxConnections满时的最大排队大小               | 默认100,注意此属性和Executor中属性maxQueueSize的区别.这个指的是请求连接满时的堆栈大小,Executor的maxQueueSize指的是处理线程满时的堆栈大小 |
| connectionTimeout | 请求连接超时                                                 | 默认60000ms                                                  |
| executor          | 指定配置的线程池名称                                         |                                                              |
| keepAliveTimeout  | keeAlive超时时间                                             | 默认值为connectionTimeout配置值.-1表示不超时                 |
| maxConnections    | 最大连接数                                                   | 连接满时后续连接放入最大为acceptCount的队列中. 对 NIO和NIO2连接,默认值为10000;对 APR/native,默认值为8192 |
| maxThreads        | 如果指定了Executor, 此属性忽略;否则为Connector创建的内部线程池最大值 | 默认200                                                      |
| minSpareThreads   | 如果指定了Executor, 此属性忽略;否则为Connector创建线程池的最小活跃线程数 | 默认10                                                       |
| processorCache    | 协议处理器缓存Processor对象的大小                            | -1表示不限制.当不使用servlet3.0的异步处理情况下: 如果配置Executor,配置为Executor的maxThreads;否则配置为Connnector的maxThreads. 如果使用Serlvet3.0异步处理, 取maxThreads和maxConnections的最大值 |

### Context

> Context元素表示一个Web应用程序，它在特定的虚拟主机中运行。每个Web应用程序都基于Web应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如Servlet规范中所述。

**属性表**

| 属性                       | 说明                                                         | 备注                                           |
| -------------------------- | ------------------------------------------------------------ | ---------------------------------------------- |
| altDDName                  | web.xml部署描述符路径                                        | 默认 /WEB-INF/web.xml                          |
| docBase                    | Context的Root路径                                            | 和Host的appBase相结合, 可确定web应用的实际目录 |
| failCtxIfServletStartFails | 同Host中的failCtxIfServletStartFails, 只对当前Context有效    | 默认为false                                    |
| logEffectiveWebXml         | 是否日志打印web.xml内容(web.xml由默认的web.xml和应用中的web.xml组成) | 默认为false                                    |
| path                       | web应用的context path                                        | 如果为根路径,则配置为空字符串(""), 不能不配置  |
| privileged                 | 是否使用Tomcat提供的manager servlet                          |                                                |
| reloadable                 | /WEB-INF/classes/ 和/WEB-INF/lib/ 目录中class文件发生变化是否自动重新加载 | 默认为false                                    |
| swallowOutput              | true情况下, System.out和System.err输出将被定向到web应用日志中 | 默认为false                                    |

### Engine

> Engine元素表示与特定的Catalina服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。

**属性表**

| 属性        | 描述                                                         | 备注                                                         |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| defaultHost | 默认主机名，用于标识将处理指向此服务器上主机名称但未在此配置文件中配置的请求的主机。 | 这个名字必须匹配其中一个嵌套的主机元素的名字属性。           |
| name        | 此引擎的逻辑名称，用于日志和错误消息。                       | 在同一服务器中使用多个服务元素时，每个引擎必须分配一个唯一的名称。 |

### Host

> Host元素表示一个虚拟主机，它是一个服务器的网络名称（如“www.mycompany.com”）与运行Tomcat的特定服务器的关联。

**属性表**

| 属性                       | 说明                                                         | 备注                                         |
| -------------------------- | ------------------------------------------------------------ | -------------------------------------------- |
| name                       | 名称                                                         | 用于日志输出                                 |
| appBase                    | 虚拟主机对应的应用基础路径                                   | 可以是个绝对路径, 或${CATALINA_BASE}相对路径 |
| xmlBase                    | 虚拟主机XML基础路径,里面应该有Context xml配置文件            | 可以是个绝对路径, 或${CATALINA_BASE}相对路径 |
| createDirs                 | 当appBase和xmlBase不存在时,是否创建目录                      | 默认为true                                   |
| autoDeploy                 | 是否周期性的检查appBase和xmlBase并deploy web应用和context描述符 | 默认为true                                   |
| deployIgnore               | 忽略deploy的正则                                             |                                              |
| deployOnStartup            | Tomcat启动时是否自动deploy                                   | 默认为true                                   |
| failCtxIfServletStartFails | 配置为true情况下,任何load-on-startup >=0的servlet启动失败,则其对应的Contxt也启动失败 | 默认为false                                  |

### Cluster



#### [官方文档](https://tomcat.apache.org/tomcat-9.0-doc/index.html)

[Configuration](https://tomcat.apache.org/tomcat-9.0-doc/config/index.html)



### work

work目录只是tomcat的工作目录，也就是tomcat把jsp转换为class文件的工作目录

当浏览器访问某个jsp页面时，tomcat会在work目录里把这个**jsp**页面转成**.java**文件,比如将index.jsp转换成index_jsp.java文件，而后编译为index_jsp.**class**文件，最后tomcat容器通过**ClassLoader**类把这个index_jsp.class类装载入内存,进行响应客户端的工作。

tomcat会**定时扫描**容器内的jsp文件,读取每个文件的属性，当发现某个jsp文件发生改变时（文件的最后修改时间与上次扫描时不相同时），tomcat会**重新转换、编译**这个jsp文件。但是tomcat的扫描是定时的不是实时的，这也正是为什么jsp文件修改后需要几分钟的时间来等修改过的jsp生效。

> 为了即刻生效，建议在修改jsp页面后立即清除work目录里的文件

关闭Tomcat
打开tomcat/work目录
删除Catalina目录
运行Tomcat

另外，tomcat容器中，对转换后的java文件（比如：index_jsp.java）的编译最大只支持**64k**，所以在其他容器中的jsp移植到tomcat容器中时会遇到大jsp文件会发生无法编译的情况，所以建议把jsp中的业务逻辑写入单独的类，在jsp中通过调用这个类的静态方法来执行，并将jsp页面中的js提取出来放到单独的js文件内

很多网友喜欢把tomcat的work目录里的东西叫做缓存，其实那不是很恰当，work目录只是tomcat的工作目录，也就是tomcat把jsp转换为class文件的工作目录，这也正是为什么它叫work目录而不是cache目录的原因



### [centos7下安装tomcat8.0](https://blog.csdn.net/xiaobaoxiaodun/article/details/53539680)

firewall-cmd –zone=public –add-port=8080/tcp –permanent

设置服务开机启动
因为centos7使用了systemd来管理服务，所以按以下步骤来设置
/etc/systemd/system/tomcat.service

```sh
[unit]
Description=Apache Tomcat Web Application Container
After=network.target
[Service]
Type=forking
ExecStart=/opt/apache-tomcat-8.5.8/bin/startup.sh
ExecStop=/opt/apache-tomcat-8.5.8/bin/shutdown.sh
[Install]
WantedBy=multi-user.target
```

systemctl enable tomcat
systemctl start tomcat
systemctl status tomcat
systemctl stop tomcat





####  [centos7中使用yum安装tomcat](https://www.cnblogs.com/qianzf/p/6986962.html)

JAVA_OPTS="-Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -Xmx512m -XX:MaxPermSize=256m -XX:+UseConcMarkSweepGC"



#### [项目打成war包并用tomcat部署](https://blog.csdn.net/zhanglf02/article/details/73565354/)

1.最简单，常见的部署方法，直接将war包放到tomcat的wabapp目录下，运行tomcat就行
2.将项目打包到本地随便一个目录位置，然后用tomcat部署该项目
F:\TomcatAppTest的文件夹，并将war包放到这里
server.xml

```xml
    <Host name="localhost"  appBase="webapps"
        unpackWARs="true" autoDeploy="true">
        <Context path="/tsqa" docBase ="F:/TomcatAppTest/tsqa" reloadable ="true" />
    </Host>
```

path:启动项目后访问的项目名 
docBase:该项目的实际放置位置的路径，注意到项目名称这一级而不是文件夹名这一级。 

使用cmd命令: jar -cvf tsqa.war tsqa 打包项目，不建议使用,打包的目录结构和用eclips打包的目录结构不同，且打的包更重，结构不合理。



#### [为Tomcat创建systemd unit 文件](https://blog.csdn.net/default7/article/details/54925702)

```sh
groupadd tomcat
mkdir /opt/tomcat
useradd -s /bin/nologin -g tomcat -d /opt/tomcat tomcat
passwd tomcat
cd /opt/tomcat
chown tomcat.tomcat -R /opt/tomcat
su - tomcat /opt/tomcat/bin/startup.sh
```

/etc/systemd/system/tomcat.service

```sh
[Unit]
Description=Apache Tomcat Web Application Container
After=syslog.target network.target

[Service]
Type=forking

Environment=JAVA_HOME=/usr/lib/jvm/jre
Environment=CATALINA_PID=/opt/tomcat/temp/tomcat.pid
Environment=CATALINA_HOME=/opt/tomcat
Environment=CATALINA_BASE=/opt/tomcat
Environment='CATALINA_OPTS=-Xms512M -Xmx1024M -server -XX:+UseParallelGC'
Environment='JAVA_OPTS=-Djava.awt.headless=true -Djava.security.egd=file:/dev/./urandom'

ExecStart=/opt/tomcat/bin/startup.sh
ExecStop=/bin/kill -15 $MAINPID

User=tomcat
Group=tomcat

[Install]
WantedBy=multi-user.target
```

##### 配置Tomcat 管理界面

/opt/tomcat/conf/tomcat-users.xml

```xml
<user username="yourusername" password="yourpassword" roles="manager-gui,admin-gui"/>
```



#### [Tomcat下使用war包发布项目](https://www.cnblogs.com/george93/p/7478756.html)

**一、静态部署**

 静态部署指的是我们在服务器启动之前部署我们的程序，只有当服务器启动之后，我们的Web应用程序才能访问。

以下3种方式都可以部署：（以PetWeb项目为例说明，PetWeb目录假设是F:/PetWeb）

1.**利用Tomcat自动部署**

 将PetWeb目录拷贝到$CATALINA_HOME/webapps下，然后启动服务器就可以了，Tomcat启动时将自动加载应用。
访问如下：http://localhost:8080/PetWeb/

这种方式比较简单，但是web应用程序必须在webapps目录下。Tomcat的Webapps目录是Tomcat默认的应用目录，当服务器启动时，会加载所有这个目录下的应用。

**2.修改Server.xml文件部署**

这种方式可以不必将PetWeb目录拷贝到webapps下，直接在F:/部署。方法如下，更改$CATALINA_HOME/conf/server.xml文件，

```xml
<Context  path ="/Pet"  reloadable ="false"  docBase ="F:/PetWeb"  workDir ="d:/Mywebapps/emp"  />
```

path：是访问时的根地址，表示访问的路径；如上述例子中，访问该应用程序地址如下：http://localhost:8080/Pet/

reloadable：表示可以在运行时在classes与lib文件夹下自动加载类包。其中reloadable="false"表示当应用程序 中的内容发生更改之后服务器不会自动加载，这个属性在开发阶段通常都设为true，方便开发，在发布阶段应该设置为false，提高应用程序的访问速度。

docbase：表示应用程序的路径，注意斜杠的方向“/”。 docBase可以使用绝对路径，也可以使用相对路径，相对路径相对于webapps。

workdir：表示缓存文件的放置地址

**3.增加自定义web部署文件(推荐使用，不需要重启Tomcat )**

这种方式和方法2差不多，但不是在Server.xml文件中添加Context标签，而是在$CATALINA_HOME/conf /Catalina/localhost中添加一个xml文件，如Pet.xml.在Tomcat安装目录conf/Catalina /localhost下，里面有Tomcat自带的三个应用，随意复制其中的一个XML文件，然后修改docbase指向你自己的应用程序，并把文件名改 名，各参数参见方法2中的<Context>标签的参数，或者你也可以自己新建一个XML文件。(注意此文件名将作为Context中的path属性值,不管文件里的path属性值如何设置也是无效的 )，将以下内容复制过去，修改相应路径即可。

```xml
<Context  path ="/Pet"  docBase ="F:/PetWeb"  
        debug ="0"  privileged ="true"  reloadable ="false"  >  
</Context>
```

访问地址如下：[http://localhost:8080/Pet/ ](http://localhost:8080/Pet/) 

**注： Web应用以.war文件的形式部署**

可以将JSP程序打包成一个war包放在目录下，服务器会自动解开这个war包，并在这个目录下生成一个同名的文件夹。一个war包就是有特性格式的jar包，它是将一个Web程序的所有内容进行压缩得到。

我们刚才是将PetWeb文件夹部署在了服务器中，我们知道可以将Web应用程序的内容打成.war 包，然后在部署在服务器上。打包请参考如下步骤： 
  1、打开命令提示符（cmd） 
  2、设置jdk环境变量 
  3、在命令提示符中进入项目文件夹F:/PetWeb后，键入如下命令：**jar cvf Pet.war \*/ .**  （注意最后有个“. ”）。这样在F:/PetWeb下应该有Pet.war文件。 （也可以打包到指定的地方，命令如下：**jar cvf d:/Pet.war \*/ .** ）

部署Pet.war文件非常简单，将刚才xml文件中的docBase ="F:/PetWeb" 更改为docBase ="F:/Pet.war" 或者直接将其拷贝到webapps目录下就可以。然后重新启动服务器就可以将Pet.war部署为一个Web应用程序了。

如果你够细心的话你会发现，服务器将Pet.war文件解开，并且在webapps下面又生成了一个Pet文件夹，然后把Pet.war的内容拷贝到里面去了。我们可以通过以下方式取消自动解压缩，将xml配置文件中的unpackWAR 属性设置为"false" 即可。



**二、动态部署**

动态部署是指可以在服务器启动之后部署web应用程序，而不用重新启动服务器。动态部署要用到服务器提供的manager.war文件，如果 在`$CATALINA_HOME/webapps/`下没有该文件，你必须去重新下载tomcat，否则不能完成以下的功能。要想使用该管理程序必须首先编 辑$CATALINA_HOME/conf/tomcat-users.xml文件，内容如下：（关于这个文件的更多内容，请参考 [Java Web应用程序的安全模型二 ](http://coresun.blog.sohu.com/70550348.html)）

```xml
<tomcat-users> 
    <role rolename="tomcat"/> 
    <role rolename="role1"/> 
    <role rolename="manager"/> 
    <user username="coresun" password="coresun" roles="manager"/> 
    <user username="tomcat" password="tomcat" roles="tomcat"/> 
    <user username="both" password="tomcat" roles="tomcat,role1"/> 
    <user username="role1" password="tomcat" roles="role1"/> 
</tomcat-users>
```

然后在浏览器中键入如下地址：[http://localhost:8080/ ](http://localhost:8080/)，应该看到一个加菲猫了吧。点击左边的Tomcat Manager链接，提示输入用户名和密码，本文都是coresun ，然后可以看到以下页面：

![img](http://hi.csdn.net/attachment/201003/22/2504700_12692438796qfN.jpg)

(1)Context Path(option): 中输入/Pet


(2)XML Configration file URL 中要指定一个.xml文件，比如我们在F:/下建立一个Pet.xml文件，内容如下：** reloadable ="false" ***\*/\** >** 。docBase 不用写了，因为要在下一个文本框中填入。或者更简单点，这个文本框什么都不填。


(3)WAR or Directory URL: 中键入F:/PetWet或者F:/Pet.war都可以，然后点击Deploy按钮，看看上面是不是已经看到了你web应用程序，名字就是你Context Path(option):中的名字。


(4)如果你部署.war文件还有更加简单的方式，下面还有个Select WAR file upload 点击浏览选择.war文件，然后点击Deploy也可以。

 

 

 

**让tomcat只运行conf/server.xml中指定的web应用**

可以有以下2种办法：

实现一: 

1)将要部署的WEB应用放在webapps以外的路径, 并在server.xml相应的**Context** 中的docBase 指定. 

2)删除webapps中的所有文件夹, 以及conf/catalina/localhost下所有xml文件. 
注: webapps是server.xml中的**Host** 元素的appBase 属性的值.

实现二: 

修改server.xml中**Host** 元素的属性, 添加或修改: deployXML ="false" deployOnStartup ="false" autoDeploy="false"

含义: 
   deployXML ="false" : 不部署conf/catalina/localhost下的xml相应的WEB应用
   deployOnStartup ="false" :tomcat启动时, 不部署webapps下的所有web应用
   autoDeploy ="false" :避免tomcat在扫描改动时, 再次把webapps下的web应用给部署进来.

**注：**

Tomcat中webapps目录下不能直接存放网页格式的文件，否则无法访问到该文件，必须有子目录才能访问该网页文件。
例如：我们直接将index.html放在webapps目录中，通过浏览器http://localhost:8080/index.html 是无法访问到index.html的。而必须要webapps/petweb/index.html才可以通过http://localhost:8080/petweb/index.html 访问到index.html页面。







### [Tomcat 安全配置与优化](https://blog.csdn.net/qq_22980667/article/details/81006883) 

#### 2.1优化server.xml

##### 2.1.1 隐藏版本信息

隐藏HTTP 头部的版本信息 。
编辑server.xml: vi /usr/local/tomcat8/conf/server.xml
为Connector 添加 server 属性

```xml
<Connector port="8080" protocol="HTTP/1.1"  connectionTimeout="20000"  redirectPort="8443" server="APP Srv1.0"/>    
```

隐藏404页面出现的版本号
![这里写图片描述](https://img-blog.csdn.net/2018042011012210?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pramtqa2xs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
针对该信息的显示是由一个jar包控制的，该jar包存放在 Tomcat 安装目录下的lib目录下，名称为 catalina.jar。
我们可以通过 jar xf 命令解压这个 jar 包会得到两个目录 META-INF 和 org ,通过修改 org/apache/catalina/util/ServerInfo.properties 文件中 的 serverinfo 字段来实现来更改我们tomcat的版本信息。

```sh
[root@localhost ~]#  cat /usr/local/tomcat8/lib/org/apache/catalina/util/ServerInfo.properties |grep -v '^$|#'
server.info=Apache Tomcat/8.0.23
server.number=8.0.23.0
server.built=Mar 18 2016 20:31:49 UTC
还有另外一种方法来实现隐藏或伪装Tomcat的版本信息，其本质和上面一样，操作如下：
[root@localhost ~]# cd /usr/local/tomcat8/lib
[root@localhost lib]# mkdir -p org/apache/catalina/util
[root@localhost lib]# cd org/apache/catalina/util
[root@localhost util]# vim ServerInfo.properties
server.info=nolinux        # 如果想修改成其它版本号，把这个地方的值改成其它值就行了
```

修改效果如下：
![这里写图片描述](https://img-blog.csdn.net/20180420110253987?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pramtqa2xs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 2.1.2 禁用Tomcat管理界面

生产环境一般不适用Tomcat默认的管理界面，这些页面存放在Tomcat 的webapps安装目录下，
把该目录下的所有文件删除即可：rm -rf /usr/local/tomcat8/webapps/*
另外删除相关的配置文件 host-manager.xml 和 manager.xml，在Tomcat 安装目录 conf/Catalina/localhost目录下。
注释或删除tomcat_user.xml 中的所有用户权限。

##### 2.1.3 应用程序安全

tomcat默认 开启了对war热部署。为了防止被植入木马恶意攻击，我们要关闭war包自动部署。
关闭自动加载最新代码（设置reloadable）
修改实例：

```xml
  <Host name="localhost"  appBase="webapps"    
	unpackWARs="false" autoDeploy="false"     
	reloadable="false">  
```

##### 2.1.4 更改关闭Tomcat的指令

server.xml中定义了可以直接关闭 Tomcat 实例的管理端口。我们通过 telnet 连接上该端口之后，输入 SHUTDOWN （此为默认关闭指 令）即可关闭 Tomcat 实例（注意，此时虽然实例关闭了，但是进程还是存在的）。由于默认关闭 Tomcat 的端口和指令都很简单。默认端口为 8005，指令为SHUTDOWN 。因此我们需要将关闭指令修改复杂一点。
当然，在新版的 Tomcat 中该端口仅监听在127.0.0.1上，因此大家也不必担心。除非黑客登陆到tomcat本机去执行关闭操作。
修改实例：

```xml
     <Server port="8005" shutdown="9SDKJ29jksjf23sjf0LSDF92JKS9DKkjsd">
```

或者禁用8005端口

```xml
     <Server port="-1" shutdown="SHUTDOWN">
```

##### 2.1.5 连接池配置

使用线程池，用较少的线程处理较多的访问，可以提高tomcat处理请求的能力。
编辑配置文件 server.xml : vi /usr/local/tomcat8/conf/server.xml
2.1.5.1 打开被注释的默认连接池配置
默认配置：

```xml
    <!--  
             <Executor name="tomcatThreadPool" namePrefix="catalina-exec-"  
                    maxThreads="150" minSpareThreads="4"/>  
                 -->  
```

修改实例：

```xml
<Executor name="tomcatThreadPool" namePrefix="catalina-exec-"  
            maxThreads="150" minSpareThreads="100"   
        prestartminSpareThreads="true" maxQueueSize="100"/> 
```

参数讲解：
name: 线程名称
namePrefix: 线程前缀
maxThreads : 最大并发连接数，不配置时默认200，一般建议设置500~ 800 ，要根据自己的硬件设施条件和实际业务需求而定。
minSpareThreads：Tomcat启动初始化的线程数，默认值25
prestartminSpareThreads：在tomcat初始化的时候就初始化minSpareThreads的值， 不设置true时minSpareThreads
maxQueueSize: 最大的等待队列数，超过则拒绝请求

2.1.5.2 修改链接配置

默认配置：

```xml
<Connector port="8080" protocol="HTTP/1.1"  
              connectionTimeout="20000"  
              redirectPort="8443" /> 
```

修改配置：

```xml
<Connector port="8080" protocol="org.apache.coyote.http11.Http11Nio2Protocol"  
	connectionTimeout="20000"  
	redirectPort="8443"   
	executor="tomcatThreadPool"  
	enableLookups="false"   
	acceptCount="100"   
	maxPostSize="10485760"   
	compression="on"   
	disableUploadTimeout="true"   
	compressionMinSize="2048"   
	noCompressionUserAgents="gozilla, traviata"   
	acceptorThreadCount="2"   
	compressableMimeType="text/html,text/xml,text/plain,text/css,text/javascript,application/javascript"   
	URIEncoding="utf-8"/>  
```

参数讲解：
port：连接端口。
protocol：连接器使用的传输方式。 Tomcat 8 设置 nio2 更好：org.apache.coyote.http11.Http11Nio2Protocol
protocol， Tomcat 6、7 设置 nio 更好：org.apache.coyote.http11.Http11NioProtocol

注：
每个web客户端请求对于服务器端来说就一个单独的线程，客户端的请求数量增多将会导致线程数就上去了，CPU就忙着 跟线程切换。
而NIO则是使用单线程(单个CPU)或者只使用少量的多线程(多CPU)来接受Socket，而由线程池来处理堵塞在pipe 或者队 列里的请求.这样的话，只要OS可以接受TCP的连接，web服务器就可以处理该请求。大大提高了web服务器的可伸缩性。
executor： 连接器使用的线程池名称
enableLookups：禁用DNS 查询
acceptCount：指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理，默认设置 100 
maxPostSize：限制 以FORM URL 参数方式的POST请求的内容大小，单位字节，默认是 2097152(2兆)，10485760 为 10M。如果要禁用限制，则可以设置为 -1
acceptorThreadCount： 用于接收连接的线程的数量，默认值是1。一般这个指需要改动的时候是因为该服务器是一个多核CPU，如果是多核 CPU 一般配置为 2
compression：传输时是压缩。
compressionMinSize：压缩的大小
noCompressionUserAgents：不启用压缩的浏览器

提示：
压缩会增加Tomcat负担，最好采用Nginx + Tomcat 或者 Apache + Tomcat 方式，压缩交由Nginx/Apache 去做。
Tomcat 的压缩是在客户端请求服务器对应资源后，从服务器端将资源文件压缩，再输出到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的 浏览过程 HTML、CSS、Javascript和Text，它可以节省40% 左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP、JSP、ASP、Servlet,SHTML等输出的网页也能进行压缩，压缩效率也很高。

##### 2.1.6 管理AJP端口

AJP是为 Tomcat 与 HTTP 服务器之间通信而定制的协议，能提供较高的通信速度和效率。如果tomcat前端放的是apache的时候，会使用到AJP这个连接 器。 默认是开启的。如果不使用apache，注释该连接器。

```xml
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
```

#### 2.2 JVM

推荐阅读：https://github.com/judasn/Linux-Tutorial/blob/master/Tomcat-Install-And-Settings.md

#### 2.3 应用程序部署

默认tomcat是root身份运行的，这样不安全。不要使用root用户启动tomcat。Java程序与C程序不同。nginx,httpd 使用root用户启动守护80端口，子进程/线程会通过setuid(),setgid()两个函数切换到普通用户。即父进程所有者是root用户，子进程与多线程所有者是一个非root用户，这个用户没有shell，无法通过ssh与控制台登陆系统，Java 的JVM 是与系统无关的，是建立在OS之上的，你使用什么用户启动Tomcat，那麽Tomcat 就会继承该所有者的权限。为了防止 Tomcat 被植入 web shell 程序后，可以修改项目文件。因此我们要将 Tomcat 和项目的属主做分离，这样子，即便被搞，他也无法创建和编辑项目文件。
设置普通用户，用来启动tomcat

```sh
groupadd tomcat
useradd -g tomcat tomcat
passwd tomcat
chown tomcat.tomcat -R /usr/local/tomcat
su - tomcat /usr/local/tomcat/bin/startup.sh
echo 'su - tomcat -c "tomcat /usr/local/tomcat/bin/startup.sh"' >> /etc/rc.local  #开机启动
```

`port="8080" address="127.0.0.1"`



### [查看版本](https://jingyan.baidu.com/article/f006222877750bfbd3f0c836.html)

linux

```sh
# 进入到bin目录后，输入catalina命令后，输出相关命令单词，version就是查看版本信息的命令
catalina.sh version

./version.sh
```

win

安装目录下的RUNNING.txt打开，最后几行，有个tomcat+版本号.exe





### [JavaWeb学习总结(二)——Tomcat服务器学习和使用(一)](https://www.cnblogs.com/xdp-gacl/p/3734395.html)





### [JavaWeb学习总结(一)——JavaWeb开发入门](https://www.cnblogs.com/xdp-gacl/p/3729033.html)

1.6、动态WEB应用的实现手段，较为常见的有以下几种：
	Microsoft ASP、ASP.NET
	PHP
	JAVA Servlet/JSP
1、Microsoft ASP、ASP.NET
　　微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。
　　ASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。
2.PHP
　　PHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。
3.Servlet/JSP
　　这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。
　　Servlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。
　　SUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。

2.2、常见的Web服务器介绍

1、WebLogic
　　WebLogic是美国bea公司出品的一个application server。BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。是目前应用最广泛的Web服务器，支持J2EE规范，而且不断的完善以适应新的开发要求

2、WebSphere
　　WebSphere Application Server 是一种功能完善、开放的Web应用程序服务器，是IBM公司电子商务计划的核心部分，它是基于 Java 的应用环境，用于建立、部署和管理 Internet 和 Intranet Web 应用程序。这一整套产品进行了扩展，以适应 Web应用程序服务器的需要，范围从简单到高级直到企业级。

3、Tomcat
　　TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范

4、IIS
　　Microsoft的Web服务器产品为Internet Information Services （IIS），IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。ⅡS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在ⅡS的平 台上。IIS提供了一个图形界面的管理工具，称为Internet信息服务管理器，可用于监视配置和控制Internet服务。
　　IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。





### [Tomcat的使用（详细流程）](https://blog.csdn.net/onlylove_longshao/article/details/53057381)

#### 1、JavaWeb概念

Java web，是用java技术来解决相关web互联网领域的技术的总称。web包括：web服务器和web客户端两部分。
java在最早web客户端的应用有java applet程序，不过这种技术在很久之前就已经被淘汰了。java在服务器端的应用非常丰富，
比如Servlet，jsp和第三方框架等等。java技术对web领域的发展注入了强大的动力

简单的说，就是使用java语言实现浏览器可以访问的程序内容。称之为Java Web

javaweb开发是基于请求和响应的：
请求：浏览器（客户端）向服务器发送信息
响应：服务器向（客户端）浏览器回送信息

请求和响应是成对出现的。

![img](https://img-blog.csdn.net/20161106225225124?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



#### 2、web资源分类：

所谓web资源即放在Internet网上供外界访问的文件或程序，又根据它们呈现的效果及原理不同，将它们划分为静态资源和动态资源。

静态web资源：固定不变数据文件（静态网页 HTML、CSS文件、文本、音频、视频）
静态web技术：HTML+CSS+JavaScript

动态web资源：一段服务程序，运行后，生成的数据文件
动态web技术：servlet，jsp，php， .net ,ruby、python等等



#### 3、常见的web服务器

web服务器简介：

```text
Tomcat：由Apache组织提供的一种Web服务器，提供对jsp和Servlet的支持。它是一种轻量级的javaWeb容器（服务器），也是当前应用最广的JavaWeb服务器（免费）。
Jboss：是一个遵从JavaEE规范的、开放源代码的、纯Java的EJB服务器，它支持所有的JavaEE规范（免费）。
GlassFish： 由Oracle公司开发的一款JavaWeb服务器，是一款强健的商业服务器，达到产品级质量（应用很少，收费）。
Resin：是CAUCHO公司的产品，是一个非常流行的应用服务器，对servlet和JSP提供了良好的支持，性能也比较优良，resin自身采用JAVA语言开发（收费，应用比较多）。
WebLogic：是Oracle公司的产品，是目前应用最广泛的Web服务器，支持JavaEE规范，而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。
```



##### 3.1、Tomcat服务器

开源小型web服务器 ，完全免费，主要用于中小型web项目，只支持Servlet和JSP 等少量javaee规范（就是JavaWeb编程接口）

##### 3.2、tomcat服务器与servlet版本的关系

servlet：sun公司提供的用于开发动态web资源的技术。
jsp：（java server page），java提供的一门开发web网页的技术。
tomcat软件：java开发的。java软件运行的时候需要jdk。

![img](https://img-blog.csdn.net/20161106225636670)

#### 4、常用的布署工程到Tomcat中的两种方式

##### 4.1、第一种方法：在tomcat目录/conf/server.xml 配置---了解

在conf/server.xml文件的host元素中配置，例如：
在host标签内书写如下内容
<Context  path="/atguigu"  docBase="D:\atguigu"/>
<Context  path="浏览器要访问的目录---虚拟目录"  docBase="网站所在磁盘目录"/>

配置好之后，要重启服务器。

> 缺点（Tomcat7.0之后）：如果配置错误：tomcat会启动失败。（如果tomcat里面存放的其他的网站），其他网站也会停机。

##### 4.2、第二种方式：将网站目录复制到tomcat/webapps目录（常用，必须掌握）

有一个网站（一个文件夹），把文件夹复制到tomcat的webapps目录下。
文件夹的名字，就是网站或者工程的访问目录.相当于之前配置 <Context path=”” 的配置

##### 4.3、把网站目录压缩成war包部署到tomcat中

war包：就是一个压缩文件 zip格式的压缩文件。 只不过扩展名不是.zip 而是.war
把我们的项目进行压缩zip，改成war，把war文件拷贝到tomcat/webapps目录下

- 把文件夹中的内容压缩成zip的格式，点击一个要部署的文件夹下面，全选 然后压缩
- 修改文件的后缀名为.war
- 把war文件复制到webapps目录下。tomcat会自己把war的文件进行解压

##### 4.4、webapps目录下/ROOT工程的访问

​	浏览器中直接输入http://ip地址:端口号   那么 默认访问的是Tomcat目录/webapps/ROOT目录
​	如果webapps下面有一个ROOT的项目。那么在访问的时候，直接可以省略项目的名字/ 表示找到root目录

#### 5、整合Tomcat和Eclipse开发工具中

#### 7、servlet

##### 7.1、servlet简介

servlet 是运行在 Web 服务器中的小型 Java 程序。servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。 
要实现此接口，可以编写一个扩展 javax.servlet.GenericServlet 的一般 servlet，或者编写一个扩展 javax.servlet.http.HttpServlet 的 HTTP servlet

7.2.4、servlet生命周期
Servlet的生命周期
	1.调用 init 方法 初始化Servlet
	2.调用 Servlet中的service方法 处理请求操作
	3.调用 destory方法 执行Servlet销毁的操作
init方法：当服务器创建一个serlvet的时候，会去调用init方法。当我们第一次去访问一个servlet的时候，会去创建这个servlet对象。并且只会创建一次。如果配置了load-on-startup 表示服务器启动的时候就创建servlet实例。
service方法：客户端每一次请求，tomcat都会去调用servcie方法。处理用户的请求。并且给其响应。每一次请求都会调用servcie方法。
estroy 方法：当服务器销毁一个servlet的时候，会调用里面的destory方法。当我们的web服务器，正常关闭的时候，会去调用destroy方法。否则不会调用destroy的方法。

##### 7.3、使用Eclipse创建Servlet程序

##### 7.4、Servlet是单例的。Servlet中的变量，它有线程安全问题。

###### 7.4.1、全局变量，数据不安全

> ![img](https://img-blog.csdn.net/20161106234819380)

###### 7.4.2、方法内的局部变量，数据安全

> ![img](https://img-blog.csdn.net/20161106234832395)





### [tomcat服务器维护心得](https://blog.csdn.net/football98/article/details/8251568)

#### 1.tomcat内存修改

通过以下现象，可以初步判断JVM内存不足：
程序抛异常，java.lang.OutOfMemoryError: Java heap space。

进入tomcat \manager\status 管理界面 查看JVM标签下的信息，当Free memory 空闲内存接近 0 ，Total menory 全部内存 接近 Max memory最大内存。这时系统反应很慢，长时间保持在这一个状态可以说明，内存不足，需要调整java程序运行过程中JVM可以调配使用的内存空间的大小（ps：可能有的程序没有释放内存也可能导致之一情况）。

解决办法：

(1)tomcat

`win`

/tomcat/bin/catalina.bat 加上下面的命令: set JAVA_OPTS=-Xms32m -Xmx256m

`unix/linux`

/tomcat/bin/catalina.sh 加上下面的命令: JAVA_OPTS="-Xms32m -Xmx256m"

添加位置如下图（ps:位置添加到哪里都无所谓，只要起作用就行）：

![img](https://img-my.csdn.net/uploads/201212/03/1354519536_7847.jpg)



(2)MyEclipse

启动MyEclipse启动Tomcat无视catalina.bat中设置内存大小的问题。

在tomcat的catalina.bat中设置set JAVA_OPTS=-Xms128m-Xmx256m，直接使用startup.bat启动tomcat没有问题。但是在myeclipse中配置tomcat后，通过myeclipse启动就

出现内存溢出，之前在catalina.bat中设置的内存似乎没有作用。

解决方法：窗口->首选项->MyEcliipse->ApplicationServers->Tomcat->Tomcat5.x->JDK->OptionalJava VM arguments中填写一下内容。

-Xms128m -Xmx256m

-Dcom.sun.management.jmxremote=true

内存具体大小视具体情况制定。



#### 2.tomcat线程池连接数修改

通过以下现象，可以初步判断tomcat线程池连接数不足：

Max threads最大线程数,Current thread当前线程线与Current thread busy当前忙碌线程相等。可以初步判断线程池连接数不足。(ps:程序连接不释放可以引起这样问题)

解决办法：

修改tomcat/conf/server.xml,在线程池节点下添加或者修改以下3个属性

```xml
<Connector port="8080" protocol="HTTP/1.1" 
           maxThreads="600"       ///最大线程数
           minSpareThreads="100"///初始化时创建的线程数
           maxSpareThreads="500"///一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。
           ...... />
```

#### 3.oracle数据库session数修改

通过以下现象，可以初步判断oracle设置的processes和session数不足：
tomcat抛出无法分发客户端连接的异常，oracle进程数不够无法连接上。

解决办法：

(1)查看processes和session

```sql
sql> select count(*) from v$process;
sql> select count(*) from v$session;
```

(2)修改processes和session

```sql
sql> alter system set processes= 300 scope=spfile;
sql> alter system set sessions= 555 scope=spfile;
```

(3)oracle的连接数(session)与其参数文件中的进程数(process)有关，它们的关系如下：

```sql
 sessions = (1.1*process+5)
```

> ps:这两个参数需要重启数据库服务才能实现修改。

#### 4.程序连接oracle数据库连接不释放

   连接不释放的产生原因有很多种，一般都是由于代码编写不规范造成的，这里不再阐述，只列出尝试解决的几种办法。

(1)Spring dataSource数据源配置 Spring 事务配置,修改Spring 配置文件 applicationContext.xml

```xml
<bean id="dataSource"  class="org.apache.commons.dbcp.BasicDataSource"
            p:driverClassName="oracle.jdbc.driver.OracleDriver" p:url="jdbc:oracle:thin:@localhost:1521:oracle"
            p:username="username" p:password="username"
            p:maxActive="200" p:maxIdle="30"       // 最大连接数量200，初始30。
            p:removeAbandoned="true"               // 如果设为true则tomcat自动检查恢复重新利用，没有正常关闭的Connection.（默认是false）。
            p:removeAbandonedTimeout="600"   // 设定连接在多少秒内被认为是放弃的连接，即可进行恢复利用。
            p:logAbandoned="true"            // 输出回收的日志，可以详细打印出异常从而发现是在那里发生了泄漏。
            p:maxWait="10000" />
```

(2)Spring 事务配置

```xml
 <!-- sessionFactory -->
 <bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
  <property name="dataSource">
   <ref bean="dataSource" />
  </property>
  <property name="hibernateProperties">
   <props>
    <prop key="hibernate.dialect">org.hibernate.dialect.OracleDialect</prop>
    <prop key="hibernate.show_sql">true</prop>
    <prop key="hibernate.format_sql">true</prop>
    <prop key="hibernate.jdbc.fetch_size">50</prop>
    <prop key="hibernate.jdbc.batch_size">50</prop>
    <prop key="hibernate.cglib.use_reflection_optimizer">false</prop>
    <prop key="hibernate.cache.provider_class">org.hibernate.cache.EhCacheProvider</prop>
   </props>
  </property>
  <property name="mappingDirectoryLocations">
   <list>
     <value>classpath:com\cg\framework\common\security\po</value>
     <value>classpath:com\cg\framework\common\config\po</value>
   </list>
  </property>
 </bean>

 <!-- 定义HibernateTemplate模板 -->
 <bean id="template" class="org.springframework.orm.hibernate3.HibernateTemplate">
   <property name="sessionFactory" ref="sessionFactory"></property>
 </bean>
 <!-- 配置JDBC操作模型 -->
 <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <constructor-arg><ref bean="dataSource"/></constructor-arg>
 </bean>
 <bean id="simpleJdbcTemplate" class="org.springframework.jdbc.core.simple.SimpleJdbcTemplate">
        <constructor-arg><ref bean="dataSource"/></constructor-arg>
  </bean>

 <!-- 配置事务-->  
 <bean id="transactionManager"  class="org.springframework.orm.hibernate3.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory" />
        <property name="dataSource" ref="dataSource"/>
    </bean>

 <aop:aspectj-autoproxy/>
 <aop:config>
  <aop:advisor pointcut="execution(* com.cg.framework.common..*Service*.*(..))" advice-ref="txAdvice"/> // Service表示事物切面位于服务层
 </aop:config>
 <tx:advice id="txAdvice" transaction-manager="transactionManager">
  <tx:attributes>
   <tx:method name="save*" propagation="REQUIRED" rollback-for="Exception"/>    //此处 rollback-for="Exception"表示，只要抛出异常就进行回滚，因为所有异常都是Exception的子类。

   <tx:method name="update*" propagation="REQUIRED" rollback-for="Exception"/> 

   <tx:method name="delete*" propagation="REQUIRED" rollback-for="Exception"/>
   <tx:method name="get*" read-only="true"/>
   <tx:method name="query*" read-only="true"/>
   <tx:method name="pageQuery" read-only="true"/>
   <tx:method name="*" propagation="REQUIRED" rollback-for="Exception"/>
  </tx:attributes>
 </tx:advice> 
```



(3)规范daoImpl层代码，仅仅使用Spring提供的3个模板，规范方法名称使其符合特定的事物。

  HibernateTemplate模板
  JdbcTemplate模板
  SimpleJdbcTemplate

  如果需要调用存储过程则使用以下方式：

```java
Connection conn = SessionFactoryUtils.getDataSource(template.getSessionFactory()).getConnection();
CallableStatement cs = conn.prepareCall("{call PRO_PRO(?,?,?,?) }");
cs.setString(1, f.getsName());
cs.setString(2, f.getDwName());
cs.setString(3, f.getDateEnd());
cs.registerOutParameter(4,OracleTypes.CURSOR );
cs.execute();
ResultSet rs =(ResultSet) cs.getObject(4);

rs.close();                                          //此处需要手动关闭连接
cs.close();
conn.close();
```

(4)配置web.xml ，设置session失效时间

  <!-- 设置session失效时间 -->
  <session-config>  
 <session-timeout>120</session-timeout>  //此处120是指120分钟，并不是大多数情况下以秒为单位。
  </session-config>

#### 5.oracle数据库锁表

有时造成系统无法正常运行的原因可能是，锁表，这里稍微提一下。

```sql
select * from v$locked_object;
```





### [tomcat 项目维护](https://blog.csdn.net/liyongjian12/article/details/52472782)

#### 1、session过期

方法一：session-timeout 在tomcat和项目的web.xml中，以分钟为单位，零或负数，则表示会话将永远不会超时

```xml
<session-config>
     <session-timeout>0</session-timeout>
</session-config>
```

方法二：HttpSession中的setMaxInactiveInterval方法，设置的是当前会话的失效时间，不是整个web服务的。setMaxInactiveInterval的参数是秒，session-config当中配置的session-timeout是分钟

#### 2、修改端口号为8090

8080改成8090

```xml
<Connector port="8090" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />
```

8009改成18009 

```xml
<Connector port="18009" protocol="AJP/1.3" redirectPort="8443" />
```

8005改成8095

```xml
<Server port="8095" shutdown="SHUTDOWN">
```



### [CentOS下 tomcat 日志维护](https://blog.csdn.net/yove_12/article/details/80696760)

修改tomcat下Catalina.sh文件

```sh
CATALINA_OUT="$CATALINA_BASE"/logs/catalina.out
改为
CATALINA_OUT="$CATALINA_BASE"/logs/catalina`date +%Y%m%d`.out
```

重启tomcat,log下的Catalina.out 已经不在有日志输出，而是生成了catalina20180614.out这个文件

```sh
#!/bin/sh
find /usr/local/software/tomcat-9-honeywell-api/logs/ -mtime +15 -exec rm -rf {} \;
```

chmod +x auto-del-15-days-ago-log.sh

crontab -e

每天凌晨1点执行auto-del-15-days-ago-log.sh脚本程序

可以通过tail -f /var/log/cron 查看定时任务执行情况





### [Tomcat使用维护手册](http://www.360doc.com/showweb/0/0/901765519.aspx)

Tomcat 优化方法探讨

1.修改了enableLookups="false" 不对每个来得请求进行反解析.

2.minProcessors="75" maxProcessors="512

​    minProcessors 设置这个参数成为正常请求时候的线程数.

​    maxprocessors 设置这个参数两倍于并发的期望请求数.

3.设置启动脚本的startup.sh, 修改JVM对于内存的使用

  -Xms(minimum) 和 -Xmx(maximum) java stack memory (java堆栈内存)

  如果设置minimum 的和最大的java statck memeory 到相同的值,能够提高GC的性能.

  确保java进程总是使用物理内存,不去使用虚拟内存.修改成为1024M (根据文档的分析介绍,可以设置大些. 设置成为1024M,观察看看)

  JAVA_OPTS="-server -Xms1024M -Xmx1024M -XX:MaxNewSize=128M -XX:NewRatio=2"

4.修改了reloadable to false (原先是true)

   当reloadable设置为true的时候,tomcat尝试 诊断web 应用的class使用改变,并自动reload任何变化.设置这个参数,减少了很多不必要的开销.

```xml
<init-param>
	<param-name>development</param-name>
	<param-value>false</param-value>
</init-param>
<init-param>
	<param-name>mappedfile</param-name>
	<param-value>false</param-value>
</init-param>
```

禁止jsp页面每次都要进行后台的重新编译,修改前设置的为true.

5.从Tomcat 5.0开始，Tomcat就已经为自己提供了一个用于监控应用服务器性能指标的servlet —— status servlet。安装完Tomcat 5之后，通过访问http://yourhost:port/manager/status就可以获得当时的应用服务器监控数据。

　　当然，为了安全起见，Tomcat 5在缺省安装时是不允许用户直接访问http://yourhost:port/manager/status的，访问的时候会给出一个403（forbidden）的错误信息。在Tomcat的Manual里说明了允许用户访问的方法：

修改conf/tomcat-users.xml文件，在其中加入 

```xml
<role rolename="manager"/>
<user username="servermon" password="passwd" roles="manager"/>
```

这样就可以在访问http://yourhost:port/manager/status时给出 servermon 的用户名与口令，查看到应用服务器的相关性能指标数据。

\* Need to restart Tomcat server to take effect.

6.监控Apache连接数，ps -ef | grep httpd | wc -l可以查看当时的Apache，这个要根据Apache连接数设定看，如果超过设定80%，证明不稳定。

watch -n 1 -d "pgrep httpd|wc -l"

To enable status reports only for browsers from the example.com domain add this code to your `httpd.conf` configuration file

```xml
<Location /server-status>
SetHandler server-status

Order Deny,Allow
Deny from all
Allow from .example.com
</Location>
```

You can now access server statistics by using a Web browser to access the page `http://your.server.name/server-status`

7.连接池http://www.360doc.com/content/10/1213/10/2614615_77608817.shtml

##### 8. [tomcat连接池泄露的监控和解决](http://blog.csdn.net/lveyo/article/details/1146061)

\1. 问题描述
Web程序在tomcat刚开始运行时速度很快，但过一段时间后发现速度变得很慢。
检查日志输出，发现异常如下:
org.apache.commons.dbcp.SQLNestedException: Cannot get a connection, pool exhausted, cause:
java.util.NoSuchElementException: Timeout waiting for idle object
同时在SQLServer事件探查器中发现，每执行一次sql语句都要产生Audit login事件，语句执行后产生
Audit logout事件。说明每一次tomcat都是重新打开新的连接。

2. 问题解决tomcat 的数据源定义提供了三个参数：a. 如果设为true则tomcat自动检查恢复重新利用，没有正常关闭的Connection.（默认是false）<parameter><name>removeAbandoned</name><value>true</value></parameter>b. 设定连接在多少秒内被认为是放弃的连接，即可进行恢复利用。<parameter><name>removeAbandonedTimeout</name><value>60</value></parameter>c. 输出回收的日志，可以详细打印出异常从而发现是在那里发生了泄漏<parameter><name>logAbandoned</name><value>true</value></parameter> 

9.查看Tomcat进程spawn的线程数：

Ps -T –p <pid> | wc -l

在tomcat配置文件server.xml中的配置中，和连接数相关的参数有：

　　minProcessors：最小空闲连接线程数，用于提高系统处理性能，默认值为10
　　maxProcessors：最大连接线程数，即：并发处理的最大请求数，默认值为75
　　acceptCount：允许的最大连接数，应大于等于maxProcessors，默认值为100
　　enableLookups：是否反查域名，取值为：true或false。为了提高处理能力，应设置为false
　　connectionTimeout：网络连接超时，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。

其中和最大连接数相关的参数为maxProcessors和acceptCount。如果要加大并发连接数，应同时加大这两个参数。

web server允许的最大连接数还受制于操作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。

server.xml中配置

```xml
 <Connector  port="8080"  
   maxThreads="150"   
   minSpareThreads="25"   
   maxSpareThreads="75"  
   acceptCount="100"  
   />
```

 maxThreads="150"   表示最多同时处理150个连接 
 minSpareThreads="25"   表示即使没有人使用也开这么多空线程等待 
 maxSpareThreads="75"   表示如果最多可以空75个线程，例如某时刻有80人访问，之后没有人访问了，则tomcat不会保留80个空线程，而是关闭5个空的。 

 acceptCount="100"  当同时连接的人数达到maxThreads时，还可以接收排队的连接，超过这个连接的则直接返回拒绝连接。

 用windows的话，著名的MaxUserPort和TcpTimedWaitDelay得先调，不然没法对比

 



**查看现有项目的struts和hibernate和spring版本**

**1. struts 版本信息**

查看 struts.jar\META-INF\MANIFEST.MF (jar -xf struts.jar META-INF/ MANIFEST.MF)
再查看 Implementation-Version
看后面的数字..

Manifest-Version: 1.0
Specification-Title: Struts Framework
Class-Path: commons-beanutils.jar commons-collections.jar commons-dig
 ester.jar commons-fileupload.jar commons-logging.jar commons-validato
 r.jar jakarta-oro.jar
Created-By: 1.3.1_04-b02 (Sun Microsystems Inc.)
Ant-Version: Apache Ant 1.6.1
Implementation-Title: Struts Framework
Specification-Version: 1.2.7
Specification-Vendor: The Apache Software Foundation
Implementation-Vendor-Id: org.apache
Extension-Name: Struts Framework
**Implementation-Version: 1.2.7**
Implementation-Vendor: The Apache Software Foundation

**2.Spring 版本信息**
查看 Spring.jar\META-INF\MANIFEST.MF
Manifest-Version: 1.0
Ant-Version: Apache Ant 1.6.5
Created-By: 1.5.0_12-b04 (Sun Microsystems Inc.)
Implementation-Title: Spring Framework
**Implementation-Version: 2.0.8**
**Spring-Version: 2.0.8**
Premain-Class: org.springframework.instrument.InstrumentationSavingAgent

**3.hibernate3 版本信息**
查看 hibernate3.jar\META-INF\MANIFEST.MF
Manifest-Version: 1.0
Created-By: 1.4.2_11-b06 (Sun Microsystems Inc.)
Ant-Version: Apache Ant 1.6.5
Implementation-Title: Hibernate3
**Hibernate-Version: 3.2.3.ga**
**Implementation-Version: 3.2.3.ga**
Implementation-Vendor: hibernate.org

其实struts2-core-2.0.14.jar就暴露出了struts的版本，就是2.0.14，也可以查看其META-INF里的MENIFEST.MF的Bundle-version.

 

**Struts2 配置文件****
**Struts2相关的配置文件有web.xml，struts.xml，struts.properties，
struts-default.xml，velocity.properties，struts-default.vm。其中web.xml，struts.xml是必须的，其它的配置文件可选择。它们在web应用中的功能如下：
web.xml：包含所有必须的框架组件的web部署描述符。
Struts.xml:配置包含result/view类型、action映射、拦截器等的Struts2的主要配置文件。
Struts.properties：配置struts2的框架属性。
Struts-default.xml：在文件在struts-action-x.x.jar中，该文件是应该被包含在struts.xml中的缺省配置。
Welocity.properties：重写了velocity的配置文件。
Struts-default.vm：相对于velocity的缺省配置。

 

在struts2中struts.xml配置文件的默认放在"/WEB-INF/classes"目录下，在项目中是src下面。

任何MVC框架都需要与Web应用整合，这就不得不借助于Struts2 web.xml文件，只有配置在Struts2 web.xml文件中Servlet才会被应用加载。

通常，所有的MVC框架都需要Web应用加载一个核心控制器，对于Struts 2框架而言，需要加载FilterDispatcher，只要Web应用负责加载FilterDispatcher，FilterDispatcher将会加载应用的Struts 2框架。

因为Struts 2将核心控制器设计成Filter，而不是一个普通Servlet。故为了让Web应用加载FilterDispacher，只需要在Struts2 web.xml文件中配置FilterDispatcher即可。

配置FilterDispatcher的代码片段如下：

```
< FILTER-CLASS>org.apache.struts2.dispatcher.FilterDispatcher 
```

```
< /FILTER-CLASS>
< INIT-PARAM>
< !-- 配置Struts 2框架默认加载的Action包结构 -->
< PARAM-NAME>actionPackages< /PARAM-NAME>
< PARAM-VALUE>org.apache.struts2.showcase.person< /PARAM-VALUE>
< /INIT-PARAM>
< !-- 配置Struts 2框架的配置提供者类 -->
< INIT-PARAM>
< PARAM-NAME>configProviders < /PARAM-NAME>
< PARAM-VALUE>lee.MyConfigurationProvider< /PARAM-VALUE>
< /INIT-PARAM>
< /FILTER>    
```



###  [Tomcat haveged](https://jingyan.baidu.com/article/f3e34a12ff8afdf5eb653519.html)

tomcat-native的功能是tomcat可以使用Apache提供的arp包

```
epel
yum install tomcat-native
```

